/*
 * ARM assembly Control Flow Graph generator
 *
 * Copyright (c) 2013, Karel De Vogeleer, ParisTech
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, see
 * <http://www.gnu.org/licenses/gpl-2.0.html>
 */


#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <map>
#include <algorithm>
#include <stdio.h>
#include <ctype.h>

#include "utils.h"

using namespace std;

vector<int> my_breaks;
vector<int> my_branches;
map<string,int> my_references;
vector<string> my_lines;
bool is_llvm = false;

	// List of all branch instructions - get these instructions from ARM ISA
	// 1. Unconditional branch
	// 2. Conditional branch (from beq to bnv - generated by gcc)
	// 3. Conditional branch (from b.eq to b.nv - generated by llvm)
	// 4. compare/testbit and branch
	// If new branch instructions are added to ISA, just update this list.
vector <string> BranchInst = {"b",
                              "beq", "bne", "bcs", "bhs", "bcc", "blo",
                              "bmi", "bpl", "bvs", "bvc", "bhi", "bls",
                              "bge", "blt", "bgt", "ble", "bal", "bnv",
                              "b.eq", "b.ne", "b.cs", "b.hs", "b.cc", "b.lo",
                              "b.mi", "b.pl", "b.vs", "b.vc", "b.hi", "b.ls",
                              "b.ge", "b.lt", "b.gt", "b.le", "b.al", "b.nv",
                              "tbz", "tbnz", "cbz", "cbnz"};

void find_breaks()
{
	int line_index;
	
	// Add the start
	my_breaks.push_back(0);
	
	for(line_index = 0; line_index < my_lines.size(); line_index++)
	{
		const char *line_c = my_lines.at(line_index).c_str();
		string line_s = my_lines.at(line_index);
		string delimit = "	"; // It's tab that separate opcode from operands.
		string inst = line_s.substr(0, line_s.find(delimit));

		if ((find(BranchInst.begin(), BranchInst.end(), inst) != BranchInst.end())) {
			my_branches.push_back(line_index);
			my_breaks.push_back(line_index+1);
		}
	}
	
	// Also insert breaks at the "pure links"
	for(map<string,int>::iterator iterator = my_references.begin(); iterator != my_references.end(); iterator++)
	{
		if(isdigit(iterator->first[1]) || (is_llvm && isdigit(iterator->first[3])))
			my_breaks.push_back(iterator->second);
	}
	
	sort(my_breaks.begin(), my_breaks.end(), less<int>());
	sort(my_branches.begin(), my_branches.end(), less<int>());
	
	// Add the end as well if not there already
	my_breaks.push_back(my_lines.size());
	
	clean_vector(&my_breaks);
	clean_vector(&my_branches);
}

void load_file ()
{
	string line;
	char *line_c;
	
	int line_index = 0;
	
	while(getline(cin, line)) {
		line_c = trim_white_spaces((char*)line.c_str());
    if (!is_llvm && strstr(line_c, "// BB#0:"))
      is_llvm = true;
		switch(line_c[0])
		{
			case '@' : break;
			case '.' :
				{
					if((!is_llvm && line_c[1] == 'L') || (is_llvm && line_c[1] == 'L' && line_c[2] == 'B'))
					{

						string my_ref = string(&line_c[1]);
            int i = 0;
            while(my_ref[i]  != ':') i++;
            string my_ref_str = my_ref.substr(0, i);
						my_references.insert(pair<string,int>(my_ref_str, my_lines.size()));
					}
					else if ((string(line_c).find("global") != std::string::npos) ||
					         (string(line_c).find("globl") != std::string::npos))
					{
						my_lines.push_back(&line_c[1]);
					}
					break;
				}
			default :
				{
					if(line_c[strlen(line_c)-1] != ':' &&
							!line.empty() &&
							(strchr(line_c, '@') == NULL) &&
							(!strstr(line_c, "-- End function")))
					{
						my_lines.push_back(line_c);
					}
				}
		}
	}
}

void print_links()
{
	for(map<string,int>::iterator iterator = my_references.begin(); iterator != my_references.end(); iterator++)
	{
		cout << iterator->first << " -> " << iterator->second << endl;
	}
}

void print_breaks()
{
	int i;
	
	for(i = 0; i < my_breaks.size(); i++)
	{
		cout << i << ": " << my_breaks.at(i) << endl;
	}
}

void print_lines()
{
	int i;
	
	for(i = 0; i < my_lines.size(); i++)
	{
		cout << i << ": " << my_lines.at(i) << endl;
	}
}

void print_header()
{
	cout << "digraph g {" << endl;
}

void print_trailer()
{
	cout << "}" << endl;
}

void list_structs()
{
	int i,k;
	
	for(i = 1; i < my_breaks.size(); i++)
	{
		//int is_cmp = 0;
		int found_end = 0;
		int found_memory = 0;
		string color = "";

		//cout << "DEBUG: " << my_breaks.at(i) << " " << my_lines.size() << endl;
		string my_shape, my_alignement;
        string my_instr = get_instr(my_lines.at(my_breaks.at(i-1)));

		/* Traditional CFG in compiler does not have a separate basic blocks for compare.
		if(is_instr(my_instr,"cmp")
			|| is_instr(my_instr.c_str(),"cmn")
			|| is_instr(my_instr.c_str(),"tst"))
			is_cmp = 1;
		
		if(is_cmp)
		{
			my_shape = "diamond";
			my_alignement = "\\n";
		}
		else
		{
		*/
			my_shape = "box";
			my_alignement = "\\l";
		//}
		// First box
		if(i == 1)
		{
			color = ", color=green";
			string my_name = get_arg(my_lines.at(0), 1);
			cout << "\tnode1 [shape=box, label =\"" << my_name;
		}
		else
		{
			cout << "\tnode" << i << " [shape=" << my_shape << ", label =\"";
			
			// List all the instructions in the block, color them if memory access.
			for(k = my_breaks.at(i-1); k < my_breaks.at(i); k++)
			{
				cout << my_lines.at(k) << my_alignement;
			
				// Detect end of function
				if(!found_end && line_containes(my_lines.at(k),"pop","pc","ret"))
					found_end = 1;
				if(!found_memory
						&& (!get_instr(my_lines.at(k)).compare("str")
							|| !get_instr(my_lines.at(k)).compare("ldr")))
					found_memory = 1;
			}
		}
		
		if(found_memory)
			color = ", color=blue";
		else if(found_end)
			color = ", color=red";
		
		cout << "\"" << color << "];" << endl;
	}
}

int convert_reference(const char *my_ref)
{
	int i = 0;
	map<string,int>::iterator iter;
	string my_ref_str;
	
	while(my_ref[i] != '.') i++;
  if (is_llvm) {
    while(my_ref[i] != 'L') i++;
	  my_ref_str = string(&my_ref[i]);
  } else {
	  my_ref_str = string(&my_ref[++i]);
  }
	
	iter = my_references.find(my_ref_str);

	if(iter != my_references.end())
		return iter->second;
	
	return -1;
}

int get_struct_index(int line)
{
	int i;

	for(i = 0; i < my_breaks.size(); i++)
	{
		if(line < my_breaks.at(i))
		{
			return i;
		}
	}
	
	return -1;
}

int print_lines_with_bb()
{
	int k = 0, l = 0, m = 0;
	
	for(k = 0; k < my_lines.size(); k++)
	{
		while(k > my_breaks.at(l))
			l++;
		if(k == my_breaks.at(l))
			cout << "--" << l+1 << "------" << endl;
		while(k > my_branches.at(m))
			m++;
		if(k == my_branches.at(m))
			cout << k << "+ " << my_lines.at(k) << endl;
		else
			cout << k << ": " << my_lines.at(k) << endl;
	}
}

void list_arrows()
{
	int i;
	
	vector<string> my_arrows;
	std::stringstream ss;
	
	// List branches
	for(i = 0; i < my_branches.size(); i++)
	{
		//cout << "Verifying branch #" << i << " at " << my_branches.at(i) << endl;
		int my_ref = convert_reference(my_lines.at(my_branches.at(i)).c_str());

		int my_struct_index_dest = get_struct_index(my_ref);
		int my_struct_index_source = get_struct_index(my_branches.at(i));
		
		if(my_struct_index_dest != -1 && my_struct_index_source != -1)
		{
			ss.str("");
			ss << "\tnode" << my_struct_index_source << " -> node" << my_struct_index_dest << ";";
			my_arrows.push_back(ss.str());
		}
		
		string test = "\tnode";
	}
	
	cout << endl;
	
	// List links between adjescent blocks
	for(i = 1; i < my_breaks.size(); i++)
	{
		if(!is_instr(get_instr(my_lines.at(my_breaks.at(i)-1)),"b")
			&& !is_instr(get_instr(my_lines.at(my_breaks.at(i)-1)),"pop")
			&& !is_instr(get_instr(my_lines.at(my_breaks.at(i)-1)),"ret"))
		{
			int my_struct_index_dest = get_struct_index(my_breaks.at(i));
			//cout << " my_struct_index_dest" << my_struct_index_dest << ";";
			ss.str("");
			ss << "\tnode" << (my_struct_index_dest-1) << " -> node" << my_struct_index_dest << ";";
			my_arrows.push_back(ss.str());
		}
	}
	
	sort(my_arrows.begin(), my_arrows.end(), less<string>());
	clean_vector(&my_arrows);
	
	for(i = 0; i < my_arrows.size(); i++)
	{
		cout << my_arrows.at(i) << endl;
	}
}

void print_clean_file ()
{
	string line;
	char *line_c;
	
	int line_index = 0;
	
	while(getline(cin, line)) {
		line_c = trim_white_spaces((char*)line.c_str());

		if(line_c[0] != '@'
			&& line_c[0] != '.'
			&& string(line_c).find(':') == std::string::npos)
				cout << line_c << endl;
	}
}

int main(int argc, const char** argv)
{
	int i = 0;

	load_file();
	find_breaks();

	for(int i = 0; i < argc; i++) {
		if(argv[i][0] == '-') {
			switch (argv[i][1]) {
				case 'f' : print_lines(); return 0;
				case 'l' : print_links(); return 0;
				case 'b' : print_breaks(); return 0;
				case 'p' : print_lines_with_bb(); return 0;
				case 'c' : print_clean_file(); return 0;
				case 'v' : cout << "ARM assembly CFG generator v1.0" << endl; return 0;
				case 'h' :
				{
					cout << "ARM assembly CFG generator parameters" << endl;
					cout << "\t-f print the assembly without comments or links" << endl;
					cout << "\t-l print the list of reference and its pointers" << endl;
					cout << "\t-b print the block borders" << endl;
					cout << "\t-p print the program together with some infered info" << endl;
					cout << "\t\t \"+\" indicates a branch" << endl;
					cout << "\t\t \"--#------\" indicates a block boundary" << endl;
					cout << "\t-v print the version of the program" << endl;
					cout << "\t-h print help information" << endl;
					return 0;
				}
			}
		}
	}

	print_header();
	list_structs();
	cout << endl;
	list_arrows();
	print_trailer();
	return 0;
}
